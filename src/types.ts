import { ComponentPublicInstance } from 'vue'
import {
  CustomMessagesConfig,
  ValidationRule,
  ValidatorFactory,
} from '@encolajs/validator'
import { FieldController, StateChanges } from './headless/useForm'

/**
 * Type definition for validation rules
 */
export type ValidationRules = Record<
  string,
  string | { name: string; rule: ValidationRule }[]
>

/**
 * Type for event triggers
 */
export type EventTrigger = 'input' | 'change' | 'blur'

/**
 * Form state options
 */
export interface FormOptions {
  /** Custom validator factory */
  validatorFactory?: ValidatorFactory
  /** Custom error messages */
  customMessages?: CustomMessagesConfig
  /** When to run validation */
  validateOn?: 'input' | 'change' | 'blur' | 'submit'
  /** Form submission handler */
  submitHandler?: (data: any, form: FormController) => Promise<void> | void
  /** Validation error callback */
  onValidationError?: (form: FormController) => void
  /** Submit success callback */
  onSubmitSuccess?: (data: any) => void
  /** Submit error callback */
  onSubmitError?: (error: any, form: FormController) => void
  /** Use global event emitter instead of form-specific one */
  useGlobalEvents?: boolean
}

/**
 * Field options interface
 */
export interface FieldOptions {
  /** Validate field on component mount */
  validateOnMount?: boolean
  /** When to validate field, overrides form setting */
  validateOn?: 'input' | 'change' | 'blur' | 'submit' | null
}

/**
 * Controller for a single form field
 * Provides access to field state, validation, and HTML binding helpers
 */
export interface FieldControllerExport {
  // Field value and state
  value: any
  error: string | null
  isDirty: boolean
  isTouched: boolean
  isValidating: boolean
  isFocused: boolean

  // Two-way binding model
  model: { value: any }

  // Methods
  validate: () => Promise<boolean>

  // Lifecycle methods (for components that need to manage field lifecycle)
  initField?: () => void
  cleanupField?: () => void

  // HTML binding helpers
  attrs: Record<string, any>
  events: Record<string, Function>

  // For arrays and custom field types
  name: string

  // ID of the field, autogenerated
  id: string
}

export interface FormController {
  // Form state properties
  $isValidating: boolean
  $isSubmitting: boolean
  $isDirty: boolean
  $isTouched: boolean

  reset(): void

  values(): object

  errors(): Record<string, string[]>

  submit(): Promise<boolean>

  validate(): Promise<boolean>

  validateField(path: string): Promise<boolean>

  setFieldValue(
    path: string,
    value: any,
    validate?: boolean,
    stateChanges?: StateChanges
  ): Promise<void>

  getFieldValue(path: string): any

  getField(path: string): FieldController

  removeField(path: string): void

  hasField(path: string): boolean

  // Event-related methods
  on(
    event: keyof import('./utils/events').FormEvents,
    handler: Function
  ): FormController

  off(
    event: keyof import('./utils/events').FormEvents,
    handler?: Function
  ): FormController

  emit(
    event: keyof import('./utils/events').FormEvents,
    data: any
  ): FormController

  // Focus/Blur handling
  setFieldFocused(path: string): void

  setFieldBlurred(path: string): void

  // Error handling
  setFieldErrors(path: string, errors: string[]): void

  setErrors(errors: Record<string, string[]>): void

  getFieldErrors(path: string): string[]

  add(arrayPath: string, index: number, item: any): void

  remove(arrayPath: string, index: number): void

  move(arrayPath: string, fromIndex: number, toIndex: number): void

  sort(arrayPath: string, callback: (a: any, b: any) => number): void

  [key: string]: any
}

/**
 * Base schema interface with common properties
 */
export interface BaseSchema {
  /**
   * The type of schema this represents
   */
  type: 'field' | 'section' | 'repeatable' | 'repeatable-table'

  /**
   * The component used for rendering this part of the form
   * Depending on each type of element there will be defaults
   */
  component?: string

  /**
   * The section this schema belongs to, used for organizing into groups
   */
  section?: string

  /**
   * Position for rendering this in the form/parent section
   */
  position?: number

  /**
   * Conditional expression to determine if the schema should be shown
   * Can be a string containing an expression referencing form state: "${form.country === 'US'}"
   * Or a boolean value
   */
  if?: string | boolean
}

/**
 * Represents the schema definition for a single form field
 */
export interface FieldSchema extends BaseSchema {
  type: 'field'

  /**
   * Label text for the field
   */
  label?: string

  /**
   * Should hide the label from the field
   */
  hideLabel?: boolean

  /**
   * For checkbox-like inputs
   */
  showLabelNextToInput?: boolean

  /**
   * Help text to display alongside the field
   */
  help?: string

  /**
   * Whether the field is required
   * Note: This is for UI purposes - actual validation is defined in validation_rules
   */
  required?: boolean | string

  /**
   * Whether to use update:modelValue event instead of input/change events
   * Some UI libraries only emit update:modelValue and don't emit input/change events
   */
  useModelValue?: boolean

  /**
   * Props to apply to the entire field component (wrapper)
   */
  props?: Record<string, any>

  /**
   * Props to apply to the label component
   */
  labelProps?: Record<string, any>

  /**
   * Props to apply to the required tag
   */
  requiredProps?: Record<string, any>

  /**
   * Props to apply to the input component
   */
  inputProps?: Record<string, any>

  /**
   * Props to apply to the help text component
   */
  helpProps?: Record<string, any>

  /**
   * Props to apply to the error message component
   */
  errorProps?: Record<string, any>

  /**
   * Component to use for this field
   * Allows direct component references
   */
  inputComponent?: string | ComponentPublicInstance
}

export interface SectionSchema extends BaseSchema {
  type: 'section'

  // title of the component
  title: string

  // tag/component used for title
  titleComponent?: string

  // props to be passed to the title
  titleProps?: Record<string, any>
}

/**
 * Schema for repeatable field groups
 */
export interface RepeatableSchema extends BaseSchema {
  type: 'repeatable'

  /**
   * The minimum number of items allowed
   */
  min?: number

  /**
   * The maximum number of items allowed
   */
  max?: number

  /**
   * The definition of fields within each repeatable item
   */
  subfields: Record<string, FieldSchema>

  /**
   * Props to apply to the repeatable container
   */
  props?: Record<string, any>

  /**
   * Default value for the field
   */
  defaultValue?: any

  /**
   * Whether to allow adding new items
   */
  allowAdd?: boolean

  /**
   * Whether to allow removing items
   */
  allowRemove?: boolean

  /**
   * Whether to allow sorting items
   */
  allowSort?: boolean

  /**
   * Whether to validate the field when a new item is added
   */
  validateOnAdd?: boolean

  /**
   * Whether to validate the field when an item is removed
   */
  validateOnRemove?: boolean
}

/**
 * Schema for repeatable fields displayed in a table format
 */
export interface RepeatableTableSchema extends BaseSchema {
  type: 'repeatable-table'

  /**
   * The minimum number of items allowed
   */
  min?: number

  /**
   * The maximum number of items allowed
   */
  max?: number

  /**
   * The definition of fields within each repeatable item
   */
  subfields: Record<string, FieldSchema>

  /**
   * Props to apply to the repeatable container
   */
  props?: Record<string, any>

  /**
   * Default value for the field
   */
  defaultValue?: any

  /**
   * Whether to allow adding new items
   */
  allowAdd?: boolean

  /**
   * Whether to allow removing items
   */
  allowRemove?: boolean

  /**
   * Whether to allow sorting items
   */
  allowSort?: boolean

  /**
   * Whether to validate the field when a new item is added
   */
  validateOnAdd?: boolean

  /**
   * Whether to validate the field when an item is removed
   */
  validateOnRemove?: boolean
}

export interface FormSchema {
  [key: string]:
    | FieldSchema
    | SectionSchema
    | RepeatableSchema
    | RepeatableTableSchema
}

export type { FieldController } from './headless/useForm'
